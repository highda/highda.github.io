<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>CGA Converter — Full Version</title>
  <style>
    body {
      margin:0; padding:0;
      font-family: system-ui,Segoe UI,Roboto,Arial;
      background: #222;
      color: #eee;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    #controls {
      position: absolute;
      top:10px; left:10px;
      background: rgba(0,0,0,0.75);
      padding: 10px;
      border-radius: 8px;
      z-index: 100;
      color: #eee;
      max-width: 320px;
      overflow-y: auto;
      max-height: 90vh;
    }
    #controls label { display: block; margin: 8px 0 2px; font-size: 0.9em; }
    #controls select, #controls input[type=range], #controls button {
      width: 100%;
      margin-bottom: 8px;
    }
    #fileList {
      background: #333;
      border: 1px dashed #555;
      padding:6px;
      max-height: 150px;
      overflow-y: auto;
      margin-bottom:8px;
      color: #ccc;
    }
    #fileList .file-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }
    #fileList button {
      font-size: 0.8em;
      margin-left:4px;
      padding:2px 6px;
    }
    #imageContainer {
      flex:1;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #111;
      overflow: auto;
    }
    #output {
      max-width: 100%;
      max-height: 100%;
      image-rendering: pixelated;
      border: none;
      cursor: pointer;
      user-select: none;
      -webkit-user-drag: none;
      -khtml-user-drag: none;
      -moz-user-drag: none;
      -o-user-drag: none;
      user-drag: none;
    }
    .small {
      font-size: 0.85em;
      color: #aaa;
    }
  </style>
</head>
<body>
  <div id="controls">
    <div id="fileList">No files selected</div>
    <label>Input image(s)</label>
    <input id="file" type="file" accept="image/*" multiple>
    <button id="loadExample">Load gradient placeholder</button>

    <label>Pre-process brightness</label>
    <input id="brightness" type="range" min="-100" max="100" step="1" value="0">
    <div class="small">Brightness: <span id="brightnessVal">0</span></div>

    <label>Factor (downscale)</label>
    <input id="factor" type="range" min="0.05" max="1" step="0.01" value="0.5">
    <div class="small">Factor: <span id="factorVal">0.50</span></div>

    <label>Palette</label>
    <select id="palette">
      <option value="Palette1High">Palette 1 High — Cyan, Magenta, White</option>
      <option value="Palette1Low">Palette 1 Low — Cyan, Magenta, Lt.Gray</option>
      <option value="Palette0High">Palette 0 High — Lt.Green, Lt.Red, Yellow</option>
      <option value="Palette0Low">Palette 0 Low — Green, Red, Brown</option>
      <option value="Palette2High">Palette 2 High — Lt.Cyan, Lt.Red, White (Mode 5)</option>
      <option value="Palette2Low">Palette 2 Low — Cyan, Red, Lt.Gray (Mode 5)</option>
      <option value="CGA16Color">CGA 16-Color (160x100 / text mode)</option>
      <option value="Old-HighIntensity">Old-HighIntensity</option>
      <option value="Old-LowIntensity">Old-LowIntensity</option>
      <option value="Old-RedCGA">Old-RedCGA</option>
    </select>

    <label>Dither</label>
    <select id="dither">
      <optgroup label="— Ordered / Bayer (JS, structured retro) —">
        <option value="js:bayer2">Bayer 2×2 (coarse)</option>
        <option value="js:bayer4">Bayer 4×4 (classic)</option>
        <option value="js:bayer8">Bayer 8×8 (fine)</option>
        <option value="js:bayer16">Bayer 16×16 (very fine)</option>
        <option value="js:cluster4">Cluster dot 4×4</option>
        <option value="js:cluster8">Cluster dot 8×8</option>
      </optgroup>
      <optgroup label="— Error diffusion (IM native, smooth) —">
        <option value="im:FloydSteinberg">Floyd-Steinberg</option>
        <option value="im:Riemersma">Riemersma</option>
      </optgroup>
      <optgroup label="— None —">
        <option value="none" selected>None (nearest colour)</option>
      </optgroup>
    </select>

    <label>Quantize colorspace</label>
    <select id="quantizeCS">
      <option value="CIELab" selected>CIELab (perceptually uniform — recommended)</option>
      <option value="LCHab">LCHab (hue-aware perceptual)</option>
      <option value="sRGB">sRGB (default ImageMagick)</option>
      <option value="Transparent">Transparent (preserves alpha)</option>
      <option value="YCbCr">YCbCr (luma-weighted)</option>
    </select>

    <label>Pre-sharpen (before quantize)</label>
    <select id="sharpen">
      <option value="none">None</option>
      <option value="mild">Mild (0×1 unsharp)</option>
      <option value="strong" selected>Strong (0×2 unsharp)</option>
    </select>

    <label>Resize filter</label>
    <select id="filter">
      <option>Point</option>
      <option>Lanczos</option>
      <option selected>Box</option>
      <option>Cubic</option>
      <option>Triangle</option>
      <option>LanczosSharp</option>
    </select>

    <label>Processing path</label>
    <select id="path">
      <option value="FirstDownscale">FirstDownscale (Downscale → Recolor → Upscale)</option>
      <option value="FirstRecolor">FirstRecolor (Recolor → Downscale → Upscale)</option>
    </select>

    <button id="convert">Convert (single)</button>
    <button id="download" disabled>Download result</button>
    <button id="saveBatch">Save Batch (ZIP)</button>
    <div class="small" id="status">Initializing...</div>
    <div class="small" id="batchProgress"></div>
  </div>

  <div id="imageContainer">
    <img id="output" alt="Processed output">
  </div>

  <script type="module">
    import * as Magick from 'https://cdn.jsdelivr.net/npm/wasm-imagemagick@1.2.8/dist/magickApi.js';

    function loadJSZip() {
      return new Promise((resolve, reject) => {
        if (window.JSZip) return resolve(window.JSZip);
        const s = document.createElement('script');
        s.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        s.onload = () => resolve(window.JSZip);
        s.onerror = reject;
        document.head.appendChild(s);
      });
    }

    const placeholderURL = 'https://upload.wikimedia.org/wikipedia/commons/8/83/LCH_Gradient_Example.png';

    const fileInput        = document.getElementById('file');
    const loadExampleBtn   = document.getElementById('loadExample');
    const fileListEl       = document.getElementById('fileList');
    const statusEl         = document.getElementById('status');
    const batchProgressEl  = document.getElementById('batchProgress');
    const brightnessInput  = document.getElementById('brightness');
    const brightnessVal    = document.getElementById('brightnessVal');
    const factorInput      = document.getElementById('factor');
    const factorVal        = document.getElementById('factorVal');
    const paletteSelect    = document.getElementById('palette');
    const ditherSelect     = document.getElementById('dither');
    const quantizeCSSelect = document.getElementById('quantizeCS');
    const sharpenSelect    = document.getElementById('sharpen');
    const filterSelect     = document.getElementById('filter');
    const pathSelect       = document.getElementById('path');
    const convertBtn       = document.getElementById('convert');
    const downloadBtn      = document.getElementById('download');
    const saveBatchBtn     = document.getElementById('saveBatch');
    const outputImg        = document.getElementById('output');

    let currentFileBuffer = null;
    let currentFileName   = '';
    let lastOutputBlob    = null;
    let queuedFiles       = [];
    let storedFilter      = filterSelect.value;

    // =========================================================================
    // Palette definitions
    // All hex values sourced directly from the canonical CGA colour table on
    // the Wikipedia "Color Graphics Adapter" article:
    //
    //   320x200 Mode 4 — two hardware palettes, each with a low/high-intensity
    //   variant. The background (colour 0) defaults to black but can be any of
    //   the 16 CGA colours; here we default to black as per BIOS initialisation.
    //
    //   Palette 0  (green / red / brown):
    //     Low:  #000000  #00AA00  #AA0000  #AA5500
    //     High: #000000  #55FF55  #FF5555  #FFFF55
    //
    //   Palette 1  (cyan / magenta / white) — the "classic CGA" look:
    //     Low:  #000000  #00AAAA  #AA00AA  #AAAAAA
    //     High: #000000  #55FFFF  #FF55FF  #FFFFFF
    //
    //   320x200 Mode 5 — colour burst disabled; on a composite monitor this
    //   produces greyscale, but on an RGBI monitor it yields a third palette
    //   not officially documented by IBM (used by some software nonetheless):
    //     Low:  #000000  #00AAAA  #AA0000  #AAAAAA
    //     High: #000000  #55FFFF  #FF5555  #FFFFFF
    //
    //   160x100 / text modes — full 16-colour CGA palette available.
    // =========================================================================
    const PALETTES = {

      // --- Mode 4, Palette 1 (the classic cyan/magenta CGA look) ---------------
      'Palette1High': [
        [0x00,0x00,0x00,0xFF], // #000000  black
        [0x55,0xFF,0xFF,0xFF], // #55FFFF  light cyan
        [0xFF,0x55,0xFF,0xFF], // #FF55FF  light magenta
        [0xFF,0xFF,0xFF,0xFF], // #FFFFFF  white
      ],
      'Palette1Low': [
        [0x00,0x00,0x00,0xFF], // #000000  black
        [0x00,0xAA,0xAA,0xFF], // #00AAAA  cyan
        [0xAA,0x00,0xAA,0xFF], // #AA00AA  magenta
        [0xAA,0xAA,0xAA,0xFF], // #AAAAAA  light gray
      ],

      // --- Mode 4, Palette 0 (green/red/brown) ----------------------------------
      'Palette0High': [
        [0x00,0x00,0x00,0xFF], // #000000  black
        [0x55,0xFF,0x55,0xFF], // #55FF55  light green
        [0xFF,0x55,0x55,0xFF], // #FF5555  light red
        [0xFF,0xFF,0x55,0xFF], // #FFFF55  yellow
      ],
      'Palette0Low': [
        [0x00,0x00,0x00,0xFF], // #000000  black
        [0x00,0xAA,0x00,0xFF], // #00AA00  green
        [0xAA,0x00,0x00,0xFF], // #AA0000  red
        [0xAA,0x55,0x00,0xFF], // #AA5500  brown
      ],

      // --- Mode 5 / "Palette 2" (cyan/red/white; RGBI only, undocumented) ------
      'Palette2High': [
        [0x00,0x00,0x00,0xFF], // #000000  black
        [0x55,0xFF,0xFF,0xFF], // #55FFFF  light cyan
        [0xFF,0x55,0x55,0xFF], // #FF5555  light red
        [0xFF,0xFF,0xFF,0xFF], // #FFFFFF  white
      ],
      'Palette2Low': [
        [0x00,0x00,0x00,0xFF], // #000000  black
        [0x00,0xAA,0xAA,0xFF], // #00AAAA  cyan
        [0xAA,0x00,0x00,0xFF], // #AA0000  red
        [0xAA,0xAA,0xAA,0xFF], // #AAAAAA  light gray
      ],

      // --- Full 16-colour palette (160x100 low-res mode / text modes) ----------
      'CGA16Color': [
        [0x00,0x00,0x00,0xFF], // #000000  black
        [0x00,0x00,0xAA,0xFF], // #0000AA  blue
        [0x00,0xAA,0x00,0xFF], // #00AA00  green
        [0x00,0xAA,0xAA,0xFF], // #00AAAA  cyan
        [0xAA,0x00,0x00,0xFF], // #AA0000  red
        [0xAA,0x00,0xAA,0xFF], // #AA00AA  magenta
        [0xAA,0x55,0x00,0xFF], // #AA5500  brown
        [0xAA,0xAA,0xAA,0xFF], // #AAAAAA  light gray
        [0x55,0x55,0x55,0xFF], // #555555  dark gray
        [0x55,0x55,0xFF,0xFF], // #5555FF  light blue
        [0x55,0xFF,0x55,0xFF], // #55FF55  light green
        [0x55,0xFF,0xFF,0xFF], // #55FFFF  light cyan
        [0xFF,0x55,0x55,0xFF], // #FF5555  light red
        [0xFF,0x55,0xFF,0xFF], // #FF55FF  light magenta
        [0xFF,0xFF,0x55,0xFF], // #FFFF55  yellow
        [0xFF,0xFF,0xFF,0xFF], // #FFFFFF  white
      ],

      // --- Legacy entries (prefixed "Old-") ------------------------------------
      // These were in the original tool but do not correspond to any documented
      // CGA hardware palette. Kept here for compatibility.
      'Old-HighIntensity': [
        [0x00,0x00,0x00,0xFF], // black
        [0x55,0xFF,0xFF,0xFF], // bright cyan
        [0xFF,0x55,0xFF,0xFF], // bright magenta
        [0xFF,0xFF,0xFF,0xFF], // white
      ],
      'Old-LowIntensity': [
        [0x00,0x00,0x00,0xFF], // black
        [0x00,0xAA,0xAA,0xFF], // cyan
        [0xAA,0x00,0xAA,0xFF], // magenta
        [0xAA,0xAA,0xAA,0xFF], // light gray
      ],
      'Old-RedCGA': [
        [0x00,0x00,0x00,0xFF], // black
        [0xAA,0x00,0x00,0xFF], // red
        [0xAA,0x55,0x00,0xFF], // brown
        [0xFF,0xFF,0xFF,0xFF], // white
      ],
    };

    // =========================================================================

    function debounce(fn, wait = 300) {
      let t = null;
      return (...args) => { if (t) clearTimeout(t); t = setTimeout(() => fn(...args), wait); };
    }

    function syncFilterEnable() {
      if (pathSelect.value === 'FirstRecolor') {
        if (filterSelect.value !== 'Point') storedFilter = filterSelect.value;
        filterSelect.value = 'Point';
        filterSelect.disabled = true;
      } else {
        filterSelect.disabled = false;
        if (storedFilter && storedFilter !== 'Point') filterSelect.value = storedFilter;
      }
    }

    brightnessInput.addEventListener('input', () => {
      brightnessVal.textContent = brightnessInput.value;
    });

    factorInput.addEventListener('input', () => {
      factorVal.textContent = Number(factorInput.value).toFixed(2);
    });

    const liveUpdate = debounce(() => { if (currentFileBuffer) runConversion(false); }, 300);

    [brightnessInput, factorInput, paletteSelect, ditherSelect, quantizeCSSelect, sharpenSelect, pathSelect].forEach(el => {
      el.addEventListener('change', () => { syncFilterEnable(); liveUpdate(); });
      el.addEventListener('input',  () => { syncFilterEnable(); liveUpdate(); });
    });
    filterSelect.addEventListener('change', () => {
      if (pathSelect.value !== 'FirstRecolor') { storedFilter = filterSelect.value; liveUpdate(); }
    });

    fileInput.addEventListener('change', async (ev) => {
      const files = ev.target.files;
      if (!files || !files.length) return;
      queuedFiles = [];
      for (const f of files) queuedFiles.push({ name: f.name, arrayBuffer: await f.arrayBuffer() });
      fileInput.value = '';
      renderFileList();
      const first = queuedFiles[0];
      if (first) selectFile(first.arrayBuffer, first.name);
    });

    loadExampleBtn.addEventListener('click', () => loadPlaceholder());

    async function loadPlaceholder() {
      try {
        statusEl.textContent = 'Loading placeholder...';
        const ab = await (await fetch(placeholderURL)).arrayBuffer();
        queuedFiles = [{ name: 'gradient.png', arrayBuffer: ab }];
        fileInput.value = '';
        renderFileList();
        selectFile(ab, 'gradient.png');
        statusEl.textContent = 'Placeholder loaded';
        runConversion(false);
      } catch (err) {
        console.error('Error loading placeholder', err);
        statusEl.textContent = 'Error loading placeholder';
      }
    }

    function renderFileList() {
      if (!queuedFiles.length) { fileListEl.innerHTML = 'No files selected'; return; }
      fileListEl.innerHTML = '';
      queuedFiles.forEach((f, idx) => {
        const row = document.createElement('div');
        row.className = 'file-row';
        const left = document.createElement('div');
        left.textContent = f.name;
        const right = document.createElement('div');
        const previewBtn = document.createElement('button');
        previewBtn.textContent = 'Preview';
        previewBtn.onclick = () => selectFile(f.arrayBuffer, f.name);
        const removeBtn = document.createElement('button');
        removeBtn.textContent = 'Remove';
        removeBtn.onclick = () => {
          queuedFiles.splice(idx, 1);
          renderFileList();
          if (!queuedFiles.length) { loadPlaceholder(); }
          else if (currentFileName === f.name) selectFile(queuedFiles[0].arrayBuffer, queuedFiles[0].name);
        };
        right.appendChild(previewBtn);
        right.appendChild(removeBtn);
        row.appendChild(left);
        row.appendChild(right);
        fileListEl.appendChild(row);
      });
    }

    function selectFile(ab, name) {
      currentFileBuffer = ab;
      currentFileName   = name;
      outputImg.src     = URL.createObjectURL(new Blob([ab]));
      lastOutputBlob    = null;
      downloadBtn.disabled = true;
      statusEl.textContent = `Selected ${name}`;
      runConversion(false);
    }

    async function buildPalettePNG(paletteName) {
      const colors  = PALETTES[paletteName] || PALETTES['Palette1High'];
      const canvas  = document.createElement('canvas');
      canvas.width  = colors.length;
      canvas.height = 1;
      const ctx  = canvas.getContext('2d');
      const imgd = ctx.createImageData(colors.length, 1);
      for (let i = 0; i < colors.length; i++) {
        imgd.data[i*4+0] = colors[i][0];
        imgd.data[i*4+1] = colors[i][1];
        imgd.data[i*4+2] = colors[i][2];
        imgd.data[i*4+3] = colors[i][3];
      }
      ctx.putImageData(imgd, 0, 0);
      return new Promise(resolve => canvas.toBlob(b => resolve(b), 'image/png'));
    }

    function extractBlob(result) {
      const tryFile = f => {
        if (!f) return null;
        if (f.blob instanceof Blob)  return f.blob;
        if (f.contents) return new Blob([f.contents], { type: 'image/png' });
        if (f.content)  return new Blob([f.content],  { type: 'image/png' });
        if (f.data)     return new Blob([f.data],      { type: 'image/png' });
        return null;
      };
      if (!result) return null;
      if (result.outputFiles?.length) {
        return tryFile(result.outputFiles.find(x => x.name?.toLowerCase().endsWith('.png')) || result.outputFiles[0]);
      }
      if (result.processedFiles?.length) return tryFile(result.processedFiles[0]);
      if (Array.isArray(result) && result.length) {
        return tryFile(result.find(x => x.name?.toLowerCase().endsWith('.png')) || result[0]);
      }
      return null;
    }

    // =========================================================================
    // Dithering
    //
    // wasm-imagemagick ships IM 7.0.8-28 which supports only three -dither
    // values: None, Riemersma, FloydSteinberg.  -dither Ordered and all Bayer
    // / halftone -ordered-dither patterns are NOT compiled into this build
    // (only "threshold" and "checks" are present in its thresholds.xml).
    //
    // Solution: Bayer / cluster-dot dithering is implemented here in JS using
    // the Canvas API.  We apply it to the image *before* passing to IM, then
    // tell IM to use -dither None -remap so it just does a nearest-colour snap
    // onto the pre-dithered signal.  This gives us any matrix we want.
    //
    // For Floyd-Steinberg / Riemersma we skip the JS pass and let IM handle it
    // natively as before.
    // =========================================================================

    // --- Bayer matrix generation (recursive) ---------------------------------
    function bayerMatrix(n) {
      // Returns a flat Float32Array of n×n values normalised to [0,1)
      if (n === 1) return new Float32Array([0]);
      const half = bayerMatrix(n / 2);
      const size = n * n;
      const m = new Float32Array(size);
      const h = n / 2;
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < h; x++) {
          const v = half[y * h + x];          // base value in [0,1)
          const scaled = v / 4;
          m[(y    ) * n + (x    )] = scaled + 0/4;  // top-left
          m[(y    ) * n + (x + h)] = scaled + 2/4;  // top-right
          m[(y + h) * n + (x    )] = scaled + 3/4;  // bottom-left
          m[(y + h) * n + (x + h)] = scaled + 1/4;  // bottom-right
        }
      }
      return m;
    }

    // --- 4×4 cluster-dot (print-style) matrix --------------------------------
    // Approximates a circular dot cluster; looks like old magazine halftones.
    const CLUSTER4 = new Float32Array([
       12, 5, 6, 13,
        4, 0, 1,  7,
       11, 3, 2,  8,
       15,10, 9, 14
    ].map(v => v / 16));

    const CLUSTER8 = (() => {
      // 8×8 cluster-dot pattern (classic Knuth / Ulichney)
      const raw = [
        24,10,12,26,35,47,49,37,
         8, 0, 2,14,45,59,61,51,
        22, 6, 4,16,43,57,63,53,
        30,20,18,28,33,41,55,39,
        34,46,48,36,25,11,13,27,
        44,58,60,50, 9, 1, 3,15,
        42,56,62,52,23, 7, 5,17,
        32,40,54,38,31,21,19,29
      ];
      return new Float32Array(raw.map(v => v / 64));
    })();

    const BAYER_CACHE = {};
    function getBayer(n) {
      if (!BAYER_CACHE[n]) BAYER_CACHE[n] = bayerMatrix(n);
      return BAYER_CACHE[n];
    }

    // --- Palette nearest-colour in linear RGB --------------------------------
    function buildLinearPalette(palName) {
      const srgb = PALETTES[palName] || PALETTES['Palette1High'];
      return srgb.map(([r, g, b]) => [
        Math.pow(r / 255, 2.2),
        Math.pow(g / 255, 2.2),
        Math.pow(b / 255, 2.2),
      ]);
    }

    function nearestPaletteColor(lr, lg, lb, linearPalette) {
      let bestD = Infinity, bestIdx = 0;
      for (let i = 0; i < linearPalette.length; i++) {
        const [pr, pg, pb] = linearPalette[i];
        const d = (lr-pr)**2 + (lg-pg)**2 + (lb-pb)**2;
        if (d < bestD) { bestD = d; bestIdx = i; }
      }
      return linearPalette[bestIdx];
    }

    // --- JS ordered dithering ------------------------------------------------
    // Applies threshold-matrix dithering directly to imageData pixels.
    // Works in linear light to avoid gamma-skewed thresholds.
    function applyOrderedDither(imageData, matrix, matrixSize, linearPalette) {
      const d = imageData.data;
      const w = imageData.width, h = imageData.height;
      // Strength: how much of the threshold to apply (1.0 = full range between
      // two palette entries; tuned per matrix size)
      const spread = 0.8;

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const i = (y * w + x) * 4;
          // sRGB → linear
          const lr = Math.pow(d[i  ] / 255, 2.2);
          const lg = Math.pow(d[i+1] / 255, 2.2);
          const lb = Math.pow(d[i+2] / 255, 2.2);

          // Threshold from matrix (centred: -0.5 … +0.5)
          const t = (matrix[(y % matrixSize) * matrixSize + (x % matrixSize)] - 0.5) * spread;

          // Apply threshold bias
          const lr2 = Math.max(0, Math.min(1, lr + t));
          const lg2 = Math.max(0, Math.min(1, lg + t));
          const lb2 = Math.max(0, Math.min(1, lb + t));

          // Snap to nearest palette colour (in linear space)
          const [pr, pg, pb] = nearestPaletteColor(lr2, lg2, lb2, linearPalette);

          // linear → sRGB
          d[i  ] = Math.round(Math.pow(pr, 1/2.2) * 255);
          d[i+1] = Math.round(Math.pow(pg, 1/2.2) * 255);
          d[i+2] = Math.round(Math.pow(pb, 1/2.2) * 255);
          // alpha unchanged
        }
      }
    }

    // Returns an ArrayBuffer of a PNG for the given imageData after JS dithering,
    // or null if dither mode is an IM-native one.
    async function applyJsDither(inArrayBuffer, targetW, targetH, filterVal) {
      const ditherVal = ditherSelect.value;
      if (!ditherVal.startsWith('js:')) return null; // IM handles it

      // Decode the source image to a canvas at the target (downscaled) size
      const blob    = new Blob([inArrayBuffer]);
      const bmp     = await createImageBitmap(blob, { resizeWidth: targetW, resizeHeight: targetH,
                                                       resizeQuality: filterVal === 'Point' ? 'pixelated' : 'high' });
      const canvas  = document.createElement('canvas');
      canvas.width  = targetW; canvas.height = targetH;
      const ctx     = canvas.getContext('2d');
      ctx.drawImage(bmp, 0, 0);
      bmp.close();

      // Optional pre-sharpen via a simple convolution isn't practical here;
      // we rely on the IM unsharp pass instead (which runs before us in the
      // FirstDownscale path, after us in FirstRecolor — see buildCmd).

      const imageData    = ctx.getImageData(0, 0, targetW, targetH);

      // Apply brightness before dithering.
      // Value is -100…+100; we add it as a direct offset in linear light.
      const bv = parseInt(brightnessInput.value, 10);
      if (bv !== 0) {
        const bLinear = Math.pow(Math.abs(bv) / 100, 2.2) * Math.sign(bv);
        const dd = imageData.data;
        for (let i = 0; i < dd.length; i += 4) {
          for (let c = 0; c < 3; c++) {
            const lin = Math.pow(dd[i+c] / 255, 2.2) + bLinear;
            dd[i+c] = Math.round(Math.pow(Math.max(0, Math.min(1, lin)), 1/2.2) * 255);
          }
        }
      }

      const linearPalette = buildLinearPalette(paletteSelect.value);

      let matrix, size;
      switch (ditherVal) {
        case 'js:bayer2':   matrix = getBayer(2);  size = 2;  break;
        case 'js:bayer4':   matrix = getBayer(4);  size = 4;  break;
        case 'js:bayer8':   matrix = getBayer(8);  size = 8;  break;
        case 'js:bayer16':  matrix = getBayer(16); size = 16; break;
        case 'js:cluster4': matrix = CLUSTER4;     size = 4;  break;
        case 'js:cluster8': matrix = CLUSTER8;     size = 8;  break;
        default:            matrix = getBayer(4);  size = 4;
      }

      applyOrderedDither(imageData, matrix, size, linearPalette);
      ctx.putImageData(imageData, 0, 0);

      return new Promise(resolve => canvas.toBlob(b => {
        b.arrayBuffer().then(ab => resolve(ab));
      }, 'image/png'));
    }

    // =========================================================================
    // ImageMagick command builder
    // =========================================================================
    function buildSharpenArgs(sharpenVal) {
      if (sharpenVal === 'mild')   return ['-unsharp', '0x1'];
      if (sharpenVal === 'strong') return ['-unsharp', '0x2'];
      return [];
    }

    function buildBrightnessArgs() {
      const bv = parseInt(brightnessInput.value, 10);
      if (bv === 0) return [];
      // IM -brightness-contrast takes a value in -100…+100 for brightness
      return ['-brightness-contrast', `${bv}x0`];
    }

    // Builds the IM command.  For JS-dithered modes the image arriving at IM is
    // already dithered and exactly the target size, so we only need remap+upscale.
    function buildCmd(origW, origH, newW, newH, filterVal, pathVal, isJsDither) {
      const sharpenArgs   = buildSharpenArgs(sharpenSelect.value);
      const brightnessArgs = buildBrightnessArgs();
      const qcs           = quantizeCSSelect.value;
      const quantizeArgs  = ['-quantize', qcs];

      if (isJsDither) {
        // Brightness was already applied in JS canvas pass; just remap + upscale.
        return [
          'convert', 'in.png',
          ...quantizeArgs,
          '-dither', 'None', '-remap', 'palette.png',
          '-filter', 'Point', '-resize', `${origW}x${origH}!`,
          'out.png'
        ];
      }

      const ditherVal  = ditherSelect.value;
      const imDither   = ditherVal === 'none'              ? 'None'
                       : ditherVal === 'im:FloydSteinberg' ? 'FloydSteinberg'
                       :                                     'Riemersma';
      const ditherArgs = ['-dither', imDither];

      if (pathVal === 'FirstDownscale') {
        return [
          'convert', 'in.png',
          ...brightnessArgs,
          '-filter', filterVal, '-resize', `${newW}x${newH}!`,
          ...sharpenArgs,
          ...quantizeArgs,
          ...ditherArgs, '-remap', 'palette.png',
          '-filter', 'Point', '-resize', `${origW}x${origH}!`,
          'out.png'
        ];
      } else {
        return [
          'convert', 'in.png',
          ...brightnessArgs,
          ...sharpenArgs,
          ...quantizeArgs,
          ...ditherArgs, '-remap', 'palette.png',
          '-filter', filterVal, '-resize', `${newW}x${newH}!`,
          '-filter', 'Point', '-resize', `${origW}x${origH}!`,
          'out.png'
        ];
      }
    }

    async function runMagick(inArrayBuffer) {
      const palName    = paletteSelect.value;
      const filterVal  = pathSelect.value === 'FirstRecolor' ? 'Point' : filterSelect.value;

      // Measure source dimensions
      const img    = new Image();
      const tmpUrl = URL.createObjectURL(new Blob([inArrayBuffer]));
      await new Promise((res, rej) => { img.onload = res; img.onerror = rej; img.src = tmpUrl; });
      const origW = img.naturalWidth || 1, origH = img.naturalHeight || 1;
      URL.revokeObjectURL(tmpUrl);

      const factor = parseFloat(factorInput.value);
      const newW   = Math.max(1, Math.round(origW * factor));
      const newH   = Math.max(1, Math.round(origH * factor));

      // For JS-dither modes, we pre-process the image in the browser
      const isJsDither = ditherSelect.value.startsWith('js:');
      let workBuffer = inArrayBuffer;

      if (isJsDither) {
        const dithered = await applyJsDither(inArrayBuffer, newW, newH, filterVal);
        if (dithered) workBuffer = dithered;
      }

      const paletteBlob = await buildPalettePNG(palName);
      const cmdArray    = buildCmd(origW, origH, newW, newH, filterVal, pathSelect.value, isJsDither);

      const u8in  = new Uint8Array(workBuffer);
      const u8pal = new Uint8Array(await paletteBlob.arrayBuffer());
      const inputFiles = [
        { name: 'in.png',      content: u8in,  blob: u8in  },
        { name: 'palette.png', content: u8pal, blob: u8pal },
      ];

      let result;
      if (typeof Magick.execute === 'function') {
        result = await Magick.execute({
          inputFiles: inputFiles.map(f => ({ name: f.name, content: f.content })),
          commands: [cmdArray.join(' ')],
        });
      } else if (typeof Magick.Call === 'function') {
        result = await Magick.Call(inputFiles.map(f => ({ name: f.name, blob: f.blob })), cmdArray);
      } else {
        throw new Error('No ImageMagick API available');
      }

      const outBlob = extractBlob(result);
      if (!outBlob) throw new Error('No output blob from ImageMagick');
      return outBlob;
    }

    async function runConversion(disableBtns = true) {
      if (!currentFileBuffer) { statusEl.textContent = 'No file selected'; return; }
      try {
        if (disableBtns) convertBtn.disabled = true;
        statusEl.textContent = 'Converting...';
        const blob = await runMagick(currentFileBuffer);
        lastOutputBlob = blob;
        outputImg.src  = URL.createObjectURL(blob);
        downloadBtn.disabled = false;
        statusEl.textContent = 'Done.';
      } catch (err) {
        console.error(err);
        statusEl.textContent = 'Error: ' + (err.message || err);
      } finally {
        if (disableBtns) convertBtn.disabled = false;
      }
    }

    convertBtn.addEventListener('click', () => runConversion(true));

    downloadBtn.addEventListener('click', () => {
      if (!lastOutputBlob) return;
      const a = document.createElement('a');
      a.href = URL.createObjectURL(lastOutputBlob);
      a.download = (currentFileName ? currentFileName.replace(/\.[^.]+$/, '') : 'out') + '-cga.png';
      document.body.appendChild(a); a.click(); a.remove();
    });

    saveBatchBtn.addEventListener('click', async () => {
      if (!queuedFiles.length) { statusEl.textContent = 'No files queued for batch'; return; }
      saveBatchBtn.disabled = true;
      batchProgressEl.textContent = 'Loading JSZip...';
      const JSZipLib = await loadJSZip();
      const zip = new JSZipLib();
      for (let i = 0; i < queuedFiles.length; i++) {
        const f = queuedFiles[i];
        batchProgressEl.textContent = `Processing ${i+1}/${queuedFiles.length}: ${f.name}`;
        try {
          const arr = await (await runMagick(f.arrayBuffer)).arrayBuffer();
          zip.file(f.name.replace(/\.[^.]+$/, '') + '-cga.png', arr);
        } catch (err) {
          console.error('Batch error:', f.name, err);
          zip.file(f.name + '-error.txt', 'Error: ' + (err.message || err));
        }
      }
      batchProgressEl.textContent = 'Generating ZIP...';
      const content = await zip.generateAsync({ type: 'blob' },
        meta => { batchProgressEl.textContent = `Zipping: ${Math.round(meta.percent)}%`; });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(content);
      a.download = 'cga-batch.zip';
      document.body.appendChild(a); a.click(); a.remove();
      batchProgressEl.textContent = `Done: ${queuedFiles.length} files.`;
      saveBatchBtn.disabled = false;
    });

    // Hold to preview original image
    let isPointerDown = false, isDragging = false, startX = 0, startY = 0;
    const DRAG_THRESHOLD = 5;

    outputImg.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      isPointerDown = true; isDragging = false;
      startX = e.clientX; startY = e.clientY;
      if (currentFileBuffer) outputImg.src = URL.createObjectURL(new Blob([currentFileBuffer]));
    });
    outputImg.addEventListener('pointermove', (e) => {
      if (!isPointerDown) return;
      if (Math.abs(e.clientX-startX) > DRAG_THRESHOLD || Math.abs(e.clientY-startY) > DRAG_THRESHOLD)
        isDragging = true;
    });
    outputImg.addEventListener('pointerup', () => {
      if (isPointerDown && !isDragging && lastOutputBlob) outputImg.src = URL.createObjectURL(lastOutputBlob);
      isPointerDown = isDragging = false;
    });
    outputImg.addEventListener('pointerleave', () => {
      if (isPointerDown && lastOutputBlob) outputImg.src = URL.createObjectURL(lastOutputBlob);
      isPointerDown = isDragging = false;
    });
    outputImg.addEventListener('pointercancel', () => {
      if (isPointerDown && lastOutputBlob) outputImg.src = URL.createObjectURL(lastOutputBlob);
      isPointerDown = isDragging = false;
    });
    outputImg.addEventListener('contextmenu', e => e.preventDefault());

    window.addEventListener('load', () => loadPlaceholder());
    syncFilterEnable();
  </script>
</body>
</html>
